Открыв среду разработки необходимо придумать название и создать новый **JAVA**
проект. Определившись c пространством имен, создадим в
папке исходников проекта соответствующую иерархию. Затем, в этой иерархии, в кодировке
**UTF8** создадим обычный java файл с информативным названием.

Предположим пространство имен будет **org.company.namespace,** а проект
**MyDemoProject**

![image](https://user-images.githubusercontent.com/29354319/70108820-25459500-1685-11ea-9a6e-cc6f882549e2.png)

Это были первые **обязательные** элементы файла описания протокола **AdHoc**.

Далее требуется описать участников информационного обмена. Они описывается **JAVA** конструкцией **class** в корне файла описания протокола.
Создадим два участника с оригинальными именами `Server` и `Client`.

![image](https://user-images.githubusercontent.com/29354319/70111774-4068d280-168e-11ea-9480-59cb265e3c43.png)

Теперь самое время описать на каких языках будут сгенерированы исходники для
`Server` и `Client`.  
Допустим узел `Server` будет сгенерирован в трех языковых
вариантах на **С\#** , **С++** и **C,**   
а узел `Client` на **Rust, Kotlin** с
прицелом на **Android**, и прочие платформы куда оно способно компилироваться, и
на **Typescript** для работе в web браузере.

Для того чтобы описать языковую конфигурацию кодогенератору, необходимо подключить в проект и
импортировать, пространство имен аннотаций **import org.unirail.AdHoc.\*;**

Требуемые языки кодогенерации выражаются **JAVA** конструкцией **implements**

![image](https://user-images.githubusercontent.com/29354319/70112135-68a50100-168f-11ea-9394-d1f1604ce316.png)


Каждый узел содержит в себе набор интерфейсов, которыми он взаимодействует с другими узлами
 
Интерфейсы узлов описываются в теле узла, **JAVA** конструкцией **interface.**
Узел может содержать неограниченное число интерфейсов. Интерфейсы в свою
очередь, конструкцией **extends** могут неограниченно наследовать свойства от других
интерфейсов

![image](https://user-images.githubusercontent.com/29354319/70112344-026cae00-1690-11ea-8c07-d113e9218e8b.png)

 
 Каждый интерфейс в свою очередь, с помощью вложенных в него **JAVA** конструкции **class**
 описывает какие пакеты через этот интерфейс узел будет способен **получить и
 обработать**. Не отправлять(!), а именно, и только, получать

 Для примера, добавим узлу `Server` возможность **получать** через созданный интерфейсе **ToMyClients**, пустой пакет `FirstPack`.

![image](https://user-images.githubusercontent.com/29354319/70112736-4c09c880-1691-11ea-9385-a433e9bf82a2.png)

Этот пакет, кроме своего ID, не содержит в себе никакой информации. Но это не
значит, что он совершенно бесполезен. Информацией является сам
факт получения этого пакета. Такие пакеты используются когда необходимо послать
некоторую информацию/сигнал с минимальными издержками.

На узле `Client` пока ничего неизвестно о возможностях узла `Server`
принимать какие либо пакеты на интерфейсе **ToMyClients**. Для завершения
конфигурирования кодогенератору нужно сообщить какими интерфейсами
взаимодействуют узлы `Client` и `Server`

Для соединения интерфейсов, в **AdHoc** используются компоненты **Channels**,
которые описывают два типа обмена

-   **StdProtocol** простой, базовый вариант предназначен для передачи по
    надежным каналам либо для сохранения информации в файл

-   **AdvProtocol** содержит в себе механизм быстрого восстановления после
    помех, подсчёт контрольной суммы и предназначен для передачи по ненадежным
    радиоканалам / UART.

Соединим интерфейс **Server.ToMyClients** с интерфейсом **Client.ToServer**
каналом с именем **ClientServerLink** и пусть этот канал будет с **AdvProtocol**
в итоге получаем следующее описание протокола.

![image](https://user-images.githubusercontent.com/29354319/70112895-ff72bd00-1691-11ea-9eb9-139f7c8acecf.png)

Выглядит понятно и логично, однако, именно как JAVA программа - совершенно бесполезно. 

Теперь эту спецификацию необходимо отправить на сервер
кодогенерации. Это делается с помощью утилиты **[AdHocAgent](https://github.com/cheblin/AdHocAgent)**

Данная прогармма способна, в зависимости от текущих требований, использовать несколько протоколов. 
 
На начальном этапе вашего проекта, когда описание протокола меняется часто и
значительно, важно как можно быстрее получать сгенерированный код. В этот момент
самым эффективным будет использование **TCP** либо **HTTP** ( если вынуждены
работать через proxy). При использовании этого вида транспорта будет происходить
максимально быстрая генерация кода без тестирования на сервере.

Далее, по мере развития проекта и его стабилизации, для большей уверенности в
сгенерированном коде, имеет смысл запрашивать генерацию с тестированием, а
поскольку это требует значительно больших ресурсов и времени, данный сервис
доступен только по **IMAP** протоколу.

Запрос на тестирование сгенерированного кода на сервере, осуществляется
добавлением в конце пути к спецификации протокола знака **!**.

>   С момента отправки файла спецификации на обработку и до получения
>   сгенерированных по нему исходников, файла спецификации будет заблокирован
>   для измерений.
>   Если блокировка в это время будет снята, **AdHocAgent** потеряет связь с уже
>   отправленой версией и не сможет получить на её ответ.

**AdHocAgent**, при получении с сервера результата кодогенерации,
будет его выгружать **в свою текущую рабочую директорию**

Возвращаясь к первому проекту, при попытке отправить его спецификацию, будет получена ошибка.

>   **WARNING: Package \< org.company.namespace.Client\$ToServer \> name component\< namespace \> is prohibited**  
>   **WARNING: Prohibited names detected**

Дело в том, что перед отправкой спецификации на сервер **AdHocAgent** проверяет использованные в
описании протокола имена.

Имена пакетов, их полей, каналов, констант и проч. не должны
начинаться / заканчиваться подчеркиванием \_ и не должны совпадать с
зарезервированными словами **ВСЕХ** языков программирования, на которых способен
генерировать **AdHoc**. Таких слов более двух сотен. И если с зарезервированными
в **JAVA** словами все просто, поскольку **JAVA**  IDE предупредит
об использовании зарезервированных в **JAVA** слов, то проверка по остальными
языкам производится утилитой **[AdHocAgent](https://github.com/cheblin/AdHocAgent)**.

Исправляем компонент пространства имён спецификации, меняем **org.company.namespace** на
**org.company.some_namespace**

![image](https://user-images.githubusercontent.com/29354319/70113481-4eb9ed00-1694-11ea-8f43-2bec3681a182.png)

Перезапускаем **AdHocAgent**, и, через короткое время, получаем сгенерированые сервером
исходники в **рабочей/текущей папке** отработавшего **AdHocAgent** процесса.

Исходник спецификации также был изменён **сервером**. И теперь она выглядит так:

![image](https://user-images.githubusercontent.com/29354319/70113601-b112ed80-1694-11ea-8182-488356d10082.png)

У `FirstPack` появился уникальный идентификатор, по которому будет определяться тип пакета. Всем пакетам, у которых не выставлен идентификатор
 сервер назначает их автоматически.
 
 Схема получившейся конфигурации 
 
 ![image](https://user-images.githubusercontent.com/29354319/70114610-fd136180-1697-11ea-919c-854723f3586a.png)